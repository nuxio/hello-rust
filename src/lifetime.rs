// Rust 中每一个**引用**都有其 生命周期 lifetime ，也就是引用保持有效的作用域

// 借用检查器 borrow checker
// 下面演示的隐含的生命周期注解
// 变量 r 的生命周期 'a 比变量 x 的生命周期 'b 长很多
// rust 在编译时会比较变量的生命周期大小
// r 引用了一个生命周期比它自身小的对象，编译就会报错
// fn example() {
//   let r;                // ---------+-- 'a
//                         //          |
//   {                     //          |
//       let x = 5;        // -+-- 'b  |
//       r = &x;           //  |       |
//   }                     // -+       |
//                         //          |
//   println!("r: {}", r); //          |
// }                       // ---------+

fn main() {
  let s1 = String::from("abcd");
  let result;
  {
    let s2 = "xyz";

    result = longest(s1.as_str(), s2);
  }
  println!("The longest string is {}", result);
}

// 生命周期注解不会改变任何引用的生命周期长短
// 生命周期注解的意义在于告诉Rust多个引用的泛型生命周期参数是如何相互联系的
// 以及关联函数参数和返回值的关系
// 类似于泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表之间的尖括号中
// 当具体的参数被传入时，'a 代表的是 x y 的生命中期中较小的哪一个
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}

// 生命周期省略
// 
// 函数或方法的参数的生命周期被称为 输入生命周期 input lifetimes
// 返回值的生命周期被称为 输出生命周期 output lifetimes
//
// 部分情况不需要手动标明生命周期注解
// 有三条规则：
// 1、每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo<'a>(x: &'a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo<'a, 'b>(x: &'a i32, y: &'b i32)，依此类推。
// 2、如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo<'a>(x: &'a i32) -> &'a i32。
// 3、如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，说明是个对象的方法(method)，那么所有输出生命周期参数被赋予 self 的生命周期。

// 静态生命周期 'static
// 其生命周期能够存活于整个程序期间
// 所有字符串字面量都拥有 'static 生命周期
fn example() {
  // 字符串字面量是被直接存储在程序二进制文件中，而这个文件总是可用的，所以所有的字符串字面量都是可用的
  let s: &'static str = "I have a static lifetime.";
}
